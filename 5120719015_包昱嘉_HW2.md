Assignment 2
======
###包昱嘉 51201719015

#####1
进程从阻塞状态转换为运行状态理论上是有可能的。假设现在CPU只有一个进程在运行，当这个进程由于等待I/O输入而阻塞，当其I/O输入完成后，由于CPU没有其他进程在运行，这个进程就可以直接从阻塞状态转换为运行状态。  
另外一种转换：从就绪态到阻塞态则是不可能的。因为一个处于就绪态的进程不可能执行其它I/O请求或者可以使得它阻塞的系统调用。

#####3
这是因为一些诸如保存寄存器值和设置堆栈指针等操作无法用C语言这一类高级语言描述，另外使用汇编语言编写的程序执行效率会比高级语言更加高效。

#####8
Web服务器应该使用内核级线程。因为如果使用的是用户级线程，用户读取文件使用正常的阻塞版本的read系统调用，此时整个服务器进程会进入block状态等待I/O输入，服务器进程的其他线程即使处于就绪状态也无法运行，如果有其他用户访问该服务器将无法得到响应。  
而如果使用的是内核级线程，当Web服务器的一个线程由于执行read系统调用而进入block状态时，内核根据其线程的调度规则进行调度，可以运行同一个进程的另一个线程或者运行另一个进程，不会影响其它用户对Web服务器的访问。   
但是相对来说使用内核级线程调度会相对比较慢，如果非要使用用户级线程的话，根据书上的相关介绍也可以使用一种用户级线程可能替代的方法。就是可以在执行read系统调用前调用select来判断预期的read系统调用是否会阻塞，在不会阻塞的前提下执行read系统调用，否则切换执行另一个线程。但这个方案需要重写部分系统调用库，所以效率也不是很高。

#####10
寄存器用来保存该线程当前的工作变量，在线程切换时需要保存当前线程寄存器的值以待下次运行时能恢复当前的工作状态，再将下一个运行的线程的寄存器值等信息读入。这点多线程和多进程切换是一致的。所以每个线程都需要自己的寄存器存储空间。  

#####12
用户级线程无法被时钟中断抢占，除非该线程所属的进程被时钟中断抢占了。内核级线程可以被时钟中断抢占。   
这是因为内核并不知道用户级线程的存在，它只是把CPU调度给了这个进程，由这个进程自己内部的调度算法来决定如何运行线程，这时时钟中断自然无法对于当前某个运行的线程进行抢占。只可能通过中断当前进程来中断这个线程的运行。  
对于内核级线程，由于内核中有用来记录系统中所有线程的线程表，所以如果某个线程运行时间过长了，内核可以单独中断这个线程，切换运行这个进程下的其他线程或者其他进程。

#####19
优先级反转之所以在内核级线程和进程之间发生是因为当优先级较低的线程或进程L进入临界区后，此时优先级比较高的线程或进程H变为就绪状态，内核通过抢占式的优先级调度，对L进行中断来运行优先级更高的线程或进程H，而由于是忙等待，L此时在临界区，H只能一直空转。  
这种优先级反转不可能在用户级线程发生，因为对于用户级线程无法进行抢占式的调度。当一个优先级比较低的线程L进入临界区时，它讲持续运行直到它阻塞或者结束运行。所以线程H并没有机会来打断线程L对于临界区的操作，也就不存在所谓的优先级反转的问题。

#####23
由于它们使用共享的公共内存，两个进程所访问的turn变量是一致的，所以采用变量turn的忙等待解决方案仍然有效。

#####26
伪代码如下，其中binary_semphore为课件ch2_2中实现的二进制信号量，其down接口为Bi_Down,up接口为Bi_Up。

	int num = 10; //计数信号量的初值
	binary_semphore M ＝ 1;
	binary_semphore N ＝ 1;
	
	Down(int sem){
		Bi_Down(M);
		sem --;
		if(sem == 0)
			Bi_Down(N);
		Bi_Up(M);
	}
	Up(int sem){
		Bi_Down(M);
		sem ++;
		if(sem == 1)
			Bi_Up(N);
		Bi_Up(M);
	}

信号量M的作用是为了防止对于num的访问产生冲突。信号量N则是用来完成计数信号量睡眠唤醒的实现。

#####33
通过分析源代码可以进行一定的判断。如果这个程序在一开始部分就把所有的输入文件读入内存，那么这个程序往往就不是I/O密集型的。相反，如果一个程序在运行过程中在循环中存在输入输出的调用，那么这个程序就很有可能是I/O密集型的。  
在UNIX系统中，我们可以通过shell命令`time`来对进程运行时间进行测试。调用格式为`time <command> [<arguments...>]` 调用的结果为：  

+ real：从命令行执行到运行结束所消耗的时间；
+ user(user CPU time)：命令在用户态中执行所消耗的CPU时间，即程序本身及其调用的库函数所使用的时间；
+ svs(system CPU time)：命令在内核态中执行所消耗的CPU时间，即由程序直接或间接调用的系统调用执行的时间。

我们可以认为user+svs代表进程CPU占用时间，在单核系统中，如果当前系统运行时间比较少，且没有其他大量I/O进程时，real-svs-user可以用来近似估计I/O耗时。

另外也可以使用ps命令查看当前进程的实际运行时间和CPU执行时间，如果实际运行时间远远大于CPU执行时间，那么可以认为该进程时I/O密集型的。

#####35
CPU的利用率为CPU运行进程的时间除以总共耗费的时间。其中总共耗费的时间包括CPU运行进程的时间和进行时间片切换的耗时。  
对于a),b)来说，由于时间片长度大于进程平均运行时间，所以进程在时间片结束前结束，CPU立即进行切换，此时CPU利用率为$$\frac{T}{T+S}$$
对于平均运行时间T小于时间片长度Q的时候，进程需要分为T/Q个时间片完成，每个时间片的切换需要耗费ST/Q的时间。所以此时CPU的利用率为$$\frac{T}{T+ST/Q}$$
当Q不断递减，CPU的利用率也不断递减。当Q＝S的时候CPU的利用率降到了50%，当Q趋近于0的时候CPU的利用率也趋近于0。

#####37
a. 第一个10min过去后，C进程结束，C的周转时间为10min;   
第二个8min过去后，D进程结束，D的周转时间为18min;  
第三个6min过去后，B进程结束，B的周转时间为24min;    
第四个4min过去后，E进程结束，E的周转时间为28min;  
最后2min过去后，A进程结束，A的周转时间为30min。  
于是采用轮转法的平均周转时间为22min。  
b. 优先级最高为B进程，先运行，B进程周转时间为6min;  
此时优先级最高为E进程，E进程周转时间为14min;  
此时优先级最高位A进程，A进程周转时间为24min;  
此时优先级最高位C进程，C进程周转时间为26min;  
最后运行D进程，D进程的周转时间为30min。
于是采用优先级调度的平均周转时间为20min。
c. 先来先到：10\*5+6\*4+2\*3+4\*2+8, 平均周转时间为19.2min。
d. 最短作业优先： 2\*5+4\*4+6\*3+8\*2+10，平均周转时间为14min。

#####45
将状态变量置为HUNGRY可以使得当前就餐的哲学家在完成就餐后询问周围哲学家是否饥饿。比如如果当前只有哲学家2在就餐，哲学家1和3处于饥饿状态。此时state[1]=HUNGRY, state[2]=EATING,state[3]=HUNGRY。当哲学家2就餐完毕后state[2]=THINKING,并紧接着调用test(LEFT)和test(RIGHT)，即询问1和3是不是可以就餐，结果发现哲学家1和3都处于HUNGRY状态，并且各自的左右邻居没有在就餐，test中的if语句为真，于是哲学家1和3开始就餐。

而如果没有将状态变为HUNGRY，当哲学家2就餐完毕后，尽管哲学家1和3之前发出过就餐请求，都处于饥饿状态，但是系统并不知道这一点所以虽然此时哲学家1和3都可以进行就餐了，但是仍然无法就餐。

#####46
这个改动会使得实际可以就餐的哲学家无法就餐。继续上题的例子，如果test(LEFT),test(RIGHT)在state[2]=THINKING之前，那么首先这两个test的尝试不会成功，这是因为在test函数中的if语句内，对于哲学家1他的state[RIGHT]==EATING,对于哲学家3他的state[LEFT]==EATING，条件语句判断没有通过，哲学家1和哲学家3无法就餐。另外更加严重的是之后哲学家1和哲学家3想要能顺利就餐就必须自己重新发起就餐请求且此时他的邻居没有在就餐，否则他们将一直保持饥饿状态。

___
声明：作业均由自己独立完成